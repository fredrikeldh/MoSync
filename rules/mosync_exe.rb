# Include this file when building MoSync code.

require "#{File.dirname(__FILE__)}/mosync_config.rb"
require "#{File.dirname(__FILE__)}/mosync.rb"
require "#{File.dirname(__FILE__)}/cExe.rb"
require "#{File.dirname(__FILE__)}/mosyncGccModule.rb"
require "#{File.dirname(__FILE__)}/mosync_resources.rb"

class PipeTask < MultiFileTask
	include FlagsChanged
	def initialize(name, objects, linkflags, files = [], prereqs = [])
		@FLAGS = linkflags
		dirTask = DirTask.new(File.dirname(name))
		@objects = objects
		@prerequisites = @objects + [dirTask] + prereqs
		super(name, files)
	end

	def cFlags
		return "#{@FLAGS} \"#{@NAME}\" \"#{@objects.join('" "')}\""
	end

	def fileExecute
		execFlags
		# pipe-tool may output an empty file and then fail.
		begin
			sh "#{mosyncdir}/bin/pipe-tool#{cFlags}"
		rescue => e
			FileUtils.rm_f(@NAME)
			raise
		end
		if(!File.exist?(@NAME))
			error "Pipe-tool failed silently!"
		end
	end
end


# adds dependency handling
class PipeResourceTask < PipeTask
	def initialize(name, objects, prereqs = [])
		@depFile = name + '.mf'
		@tempDepFile = "#{@depFile}t"

		super(name, objects, " -depend=#{@tempDepFile} -R", [], prereqs)
	end
	def setNeeded
		super
		if(!needed)
			if(!File.exists?(@depFile))
				@needed = "Because the dependency file is missing:"
			else
				@prerequisites += MakeDependLoader.load(@depFile, name)
			end
		end
	end
	def fileExecute
		super
		FileUtils.mv(@tempDepFile, @depFile)
	end
end

class MoSyncExe < ExeWork
	include MoSyncInclude

	# Returns pipe-tool flags for memory settings,
	# with a datasize of 2^pow2kb KiB.
	# For example, for 2 MiB, call standardMemorySettings(11).
	# A power-of-2 argument may seem strange, but because the runtimes
	# force datasize to the closest upper power-of-2 anyway,
	# it should minimize accidental memory waste.
	def standardMemorySettings(pow2kb)
		raise "Insufficient memory. Need at least 64 KiB." if(pow2kb < 6)
		d = (1 << (pow2kb))
		h = d - (d >> 2)
		s = (d >> 4)
		return " -heapsize #{h} -stacksize #{s}"
	end

	def initialize(compilerModule = DefaultMoSyncCCompilerModule, &block)
		super(compilerModule) do
			instance_eval(&block)
			# String, GCC flags describing the default include directories.
			default(:DEFAULT_INCLUDES, " -I\"#{mosync_include}\"")
			# String, name of target device profile.
			default(:MOSYNC_PROFILE, 'MoSync/Emulator')
			# String, GCC flags describing the profile include directory.
			default(:PROFILE_INCLUDE, " -I\"#{mosyncdir}/profiles/vendors/#{@MOSYNC_PROFILE}\"")
			# Array of Strings, names of .lst files used to build a 'resources' file.
			# If this is false or nil, it will be populated from @SOURCES[0].
			default(:LSTFILES, nil)
			# Array of Tasks, prerequisites of the autogenerated PipeResourceTask from LSTFILES.
			default(:LST_PREREQS, [])
			# Array of Strings, names of default libraries.
			if(USE_NEWLIB)
				default(:DEFAULT_LIBS, ['newlib'])
			else
				default(:DEFAULT_LIBS, ['mastd'])
			end

			d = @DEFAULT_INCLUDES + @PROFILE_INCLUDE

			@EXTRA_CFLAGS ||= ''
			@EXTRA_CFLAGS = d + @EXTRA_CFLAGS
			@EXTRA_CPPFLAGS ||= ''
			@EXTRA_CPPFLAGS = d + @EXTRA_CPPFLAGS

			# must be called before set_defaults.
			checkSources

			# sets BUILDDIR_BASE.
			set_defaults

			# rescomp support
			if(@LSTX)
				lstxTask = RescompTask.new(@BUILDDIR_BASE, @LSTX, @RES_PLATFORM)
				@resourceTask = PipeResourceTask.new('build/resources', [lstxTask])
			end

			# If LSTFILES was not specified, search for them in SOURCES[0].
			if(!@LSTFILES)
				if(@SOURCES && @SOURCES[0])
					@LSTFILES = Dir[@SOURCES[0] + "/*.lst"]
				else
					@LSTFILES = []
				end
			end

			# Add resourceTask as a requirement.
			@REQUIREMENTS ||= []
			if(@resourceTask)
				@REQUIREMENTS << @resourceTask
			elsif(@LSTFILES.size > 0)
				lstTasks = @LSTFILES.collect do |name| FileTask.new(name) end
				@resourceTask = PipeResourceTask.new('build/resources', lstTasks, @LST_PREREQS)
				@REQUIREMENTS << @resourceTask
			end

			# Move link flags to the MX task.
			@mxLinkFlags = @EXTRA_LINKFLAGS
			@EXTRA_LINKFLAGS = ''
		end
		@mxTask = Mapip2MxTask.new(self, @mxLinkFlags)
		Works.setDefaultTarget(:run) do
			sh emuCommandLine
		end
	end
	def targetName()
		return CCompileTask.genFilename(@BUILDDIR, @NAME, '.elf')
	end
	def emuCommandLine
		if(@resourceTask)
			resArg = " -resource \"#{@resourceTask}\""
		end
		if(@EXTENSIONS)
			extArg = " -x build/mxConfig.txt"
		end
		sldArg = " -sld \"#{@mxTask}.sld\""
		prefix = "LD_LIBRARY_PATH=#{mosyncdir}/bin:$LD_LIBRARY_PATH " if(HOST == :linux)
		return "#{prefix}#{mosyncdir}/bin/MoRE -program \"#{@mxTask}\"#{sldArg}#{resArg}#{extArg}#{@EXTRA_EMUFLAGS}"
	end
end

class Mapip2MxTask < MultiFileTask
	include FlagsChanged
	def initialize(prereq, mxFlags)
		@elfName = prereq.to_s
		@mxFlags = mxFlags
		name = @elfName.ext('')
		@sldName = name + '.sld'
		@prerequisites = [prereq]
		super(name, [@sldName])
	end
	def cFlags
		return " -mx #{@NAME}#{@mxFlags} #{@elfName} #{@sldName}"
	end
	def fileExecute
		sh "#{mosyncdir}/bin/elfStabSld#{cFlags}"
		# make sure sld file is newer than mx file.
		FileUtils.touch @sldName
		execFlags
	end
end
