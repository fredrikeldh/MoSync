# Include this file when building MoSync code.

require "#{File.dirname(__FILE__)}/arg_handler.rb"
require "#{File.dirname(__FILE__)}/cExe.rb"

class MoSyncExe < ExeWork
	@@PACK = false
	def self.setPack(v)
		@@PACK = v
	end
end

Works.registerArgHandler(:PACK) do |value|
	MoSyncExe.setPack(value)
end

require "#{File.dirname(__FILE__)}/mosync_config.rb"
require "#{File.dirname(__FILE__)}/mosync.rb"
require "#{File.dirname(__FILE__)}/mosyncGccModule.rb"
require "#{File.dirname(__FILE__)}/mosync_resources.rb"

class PipeTask < MultiFileTask
	include FlagsChanged
	def initialize(name, objects, linkflags, files = [], prereqs = [])
		@FLAGS = linkflags
		dirTask = DirTask.new(File.dirname(name))
		@objects = objects
		@prerequisites = @objects + [dirTask] + prereqs
		super(name, files)
	end

	def cFlags
		return "#{@FLAGS} \"#{@NAME}\" \"#{@objects.join('" "')}\""
	end

	def fileExecute
		execFlags
		# pipe-tool may output an empty file and then fail.
		begin
			sh "#{mosyncdir}/bin/pipe-tool#{cFlags}"
		rescue => e
			FileUtils.rm_f(@NAME)
			raise
		end
		if(!File.exist?(@NAME))
			error "Pipe-tool failed silently!"
		end
	end
end


# adds dependency handling
class PipeResourceTask < PipeTask
	def initialize(name, objects, prereqs = [])
		@depFile = name + '.mf'
		@tempDepFile = "#{@depFile}t"

		super(name, objects, " -depend=#{@tempDepFile} -R", [], prereqs)
	end
	def setNeeded
		super
		if(!needed)
			if(!File.exists?(@depFile))
				@needed = "Because the dependency file is missing:"
			else
				@prerequisites += MakeDependLoader.load(@depFile, name)
			end
		end
	end
	def fileExecute
		super
		FileUtils.mv(@tempDepFile, @depFile)
	end
end

class MoSyncExe < ExeWork
	include MoSyncInclude

	# Returns pipe-tool flags for memory settings,
	# with a datasize of 2^pow2kb KiB.
	# For example, for 2 MiB, call standardMemorySettings(11).
	# A power-of-2 argument may seem strange, but because the runtimes
	# force datasize to the closest upper power-of-2 anyway,
	# it should minimize accidental memory waste.
	def standardMemorySettings(pow2kb)
		raise "Insufficient memory. Need at least 64 KiB." if(pow2kb < 6)
		d = (1 << (pow2kb))
		h = d - (d >> 2)
		s = (d >> 4)
		return " -heapsize #{h} -stacksize #{s}"
	end

	def initialize(compilerModule = DefaultMoSyncCCompilerModule, &block)
		super(compilerModule) do
			instance_eval(&block)
			if(@@PACK)
				default(:MOSYNC_PROFILE, @@PACK)
			end

			@appName = @NAME.clone

			# String, GCC flags describing the default include directories.
			default(:DEFAULT_INCLUDES, " -I\"#{mosync_include}\"")
			# String, name of target device profile.
			default(:MOSYNC_PROFILE, 'MoSync/Emulator')
			# String, GCC flags describing the profile include directory.
			default(:PROFILE_INCLUDE, " -I\"#{mosyncdir}/profiles/vendors/#{@MOSYNC_PROFILE}\"")
			# Array of Strings, names of .lst files used to build a 'resources' file.
			# If this is false or nil, it will be populated from @SOURCES[0].
			default(:LSTFILES, nil)
			# Array of Tasks, prerequisites of the autogenerated PipeResourceTask from LSTFILES.
			default(:LST_PREREQS, [])
			# Array of Strings, names of default libraries.
			if(USE_NEWLIB)
				default(:DEFAULT_LIBS, ['newlib'])
			else
				default(:DEFAULT_LIBS, ['mastd'])
			end

			d = @DEFAULT_INCLUDES + @PROFILE_INCLUDE

			@EXTRA_CFLAGS ||= ''
			@EXTRA_CFLAGS = d + @EXTRA_CFLAGS
			@EXTRA_CPPFLAGS ||= ''
			@EXTRA_CPPFLAGS = d + @EXTRA_CPPFLAGS

			# must be called before set_defaults.
			checkSources

			# sets BUILDDIR_BASE.
			set_defaults

			# rescomp support
			if(@LSTX)
				lstxTask = RescompTask.new(@BUILDDIR_BASE, @LSTX, @RES_PLATFORM)
				@resourceTask = PipeResourceTask.new('build/resources', [lstxTask])
			end

			# If LSTFILES was not specified, search for them in SOURCES[0].
			if(!@LSTFILES)
				if(@SOURCES && @SOURCES[0])
					@LSTFILES = Dir[@SOURCES[0] + "/*.lst"]
				else
					@LSTFILES = []
				end
			end

			# Add resourceTask as a requirement.
			@REQUIREMENTS ||= []
			if(@resourceTask)
				@REQUIREMENTS << @resourceTask
			elsif(@LSTFILES.size > 0)
				lstTasks = @LSTFILES.collect do |name| FileTask.new(name) end
				@resourceTask = PipeResourceTask.new('build/resources', lstTasks, @LST_PREREQS)
				@REQUIREMENTS << @resourceTask
			end

			# Move link flags to the MX task.
			@mxLinkFlags = @EXTRA_LINKFLAGS
			@EXTRA_LINKFLAGS = ''
		end

		@mxTask = Mapip2MxTask.new(self, @mxLinkFlags)
		Works.setDefaultTarget(:run) do
			sh emuCommandLine
		end

		if(@@PACK)
			default(:PACK_MODEL, @@PACK)
			default(:PACK_VERSION, '1.0')
			default(:PACK_ICON, mosyncdir+'/etc/default.icon')
			default(:PACK_IOS_CERT, 'iPhone developer')
			default(:PACK_CPP_OUTPUT, @BUILDDIR)
			default(:PACK_ANDROID_PACKAGE, "com.mosync.app_#{@appName}")
			default(:PACK_ANDROID_VERSION_CODE, 1)
			default(:PACK_ANDROID_KEYSTORE, mosyncdir+'/etc/mosync.keystore')
			default(:PACK_ANDROID_STOREPASS, 'default')
			default(:PACK_ANDROID_ALIAS, 'mosync.keystore')
			default(:PACK_ANDROID_KEYPASS, 'default')

			MoSyncPackTask.new({
				:tempdir => @BUILDDIR_BASE,
				:buildpath => @BUILDDIR,
				:model => @PACK_MODEL,
				:program => @mxTask,
				:resource => @resourceTask,
				:name => @appName,
				:vendor => @VENDOR,
				:version => @PACK_VERSION,
				:icon => @PACK_ICON,
				:iosCert => @PACK_IOS_CERT,
				:cppOutput => @PACK_CPP_OUTPUT,
				:androidPackage => @PACK_ANDROID_PACKAGE,
				:androidVersionCode => @PACK_ANDROID_VERSION_CODE,
				:androidKeystore => @PACK_ANDROID_KEYSTORE,
				:androidStorepass => @PACK_ANDROID_STOREPASS,
				:androidAlias => @PACK_ANDROID_ALIAS,
				:androidKeypass => @PACK_ANDROID_KEYPASS,
				:extraParameters => @PACK_PARAMETERS,
			})
		end
	end
	def targetName()
		return CCompileTask.genFilename(@BUILDDIR, @NAME, '.elf')
	end
	def emuCommandLine
		if(@resourceTask)
			resArg = " -resource \"#{@resourceTask}\""
		end
		if(@EXTENSIONS)
			extArg = " -x build/mxConfig.txt"
		end
		sldArg = " -sld \"#{@mxTask}.sld\""
		prefix = "LD_LIBRARY_PATH=#{mosyncdir}/bin:$LD_LIBRARY_PATH " if(HOST == :linux)
		return "#{prefix}#{mosyncdir}/bin/MoRE -program \"#{@mxTask}\"#{sldArg}#{resArg}#{extArg}#{@EXTRA_EMUFLAGS}"
	end
end

class Mapip2MxTask < MultiFileTask
	include FlagsChanged
	def initialize(prereq, mxFlags)
		@elfName = prereq.to_s
		@mxFlags = mxFlags
		name = @elfName.ext('')
		@sldName = name + '.sld'
		@prerequisites = [prereq]
		super(name, [@sldName])
	end
	def cFlags
		return " -mx #{@NAME}#{@mxFlags} #{@elfName} #{@sldName}"
	end
	def fileExecute
		sh "#{mosyncdir}/bin/elfStabSld#{cFlags}"
		# make sure sld file is newer than mx file.
		FileUtils.touch @sldName
		execFlags
	end
end

def openssl
	#if(HOST != :win32)
		return 'openssl'
	#else
	#	return "#{mosyncdir}/bin/openssl -config \"#{mosyncdir}/bin/openssl.cnf\""
	#end
end

class GenKeyTask < FileTask
	def fileExecute
		sh "#{openssl} genrsa -rand -des -passout pass:default -out \"#{@NAME}\" 1024"
	end
end

class GenCertTask < FileTask
	def initialize(name, key, req)
		@key = key
		@prerequisites = [key]
		@requirements = [req]
		super(name)
	end
	def fileExecute
		sh "#{openssl} req -new -x509 -nodes -sha1 -days 3650"+
			" -key \"#{@key}\" -batch -out \"#{@NAME}\""
	end
end

class EtcDirTask < CopyDirTask
	def initialize
		# Copy whatever default_etc files are missing.
		super(mosyncdir, 'etc', "#{mosyncdir}/bin/default_etc")
		# Generate default.cert and key.
		GenCertTask.new("#{mosyncdir}/etc/default.cert",
			GenKeyTask.new("#{mosyncdir}/etc/default.key"), self)
	end
end

# Packs a MoSync program for installation.
# resource can be nil. all other parameters must be valid.
class MoSyncPackTask < FileTask
	def initialize(options = {})
		@o = options
		#p options
		@o[:packpath] = @o[:buildpath] + @o[:model] if(!@o[:packpath])
		@prerequisites = [@o[:program], DirTask.new(@o[:packpath])]
		@prerequisites << @o[:resource] if(@o[:resource])
		@prerequisites << EtcDirTask.new
		@o[:vendor] = 'Built with MoSync' if(!@o[:vendor])
		super(@o[:packpath] + '/packComplete.empty')
	end
	def fileExecute
		p = File.expand_path(@o[:program])
		d = File.expand_path(@o[:packpath])
		co = File.expand_path(@o[:cppOutput])
		cmd = "#{mosyncdir}/bin/package -p \"#{p}\""
		if(@o[:resource])
			r = File.expand_path(@o[:resource])
			cmd << " -r \"#{r}\""
		end
		cmd << " -m \"#{@o[:model]}\""+
			" -d \"#{d}\" -n \"#{@o[:name]}\" --vendor \"#{@o[:vendor]}\""+
			" --version #{@o[:version]}"
		cmd << " --icon \"#{File.expand_path(@o[:icon])}\"" if(@o[:icon])
		cmd << " --ios-cert \"#{File.expand_path(@o[:iosCert])}\""+
			" --cpp-output \"#{co}\" --ios-project-only"+
			" --wp-config release_rebuild"+
			" --cs-output \"#{co}\""
		cmd << " --wp-project-only" if(!MSBUILD_PATH)
		cmd << " --wp-vs-build-path \"#{MSBUILD_PATH}\"" if(MSBUILD_PATH)
		cmd << " --android-package \"#{@o[:androidPackage]}\""+
			" --android-version-code \"#{@o[:androidVersionCode]}\""+
			" --android-keystore \"#{File.expand_path(@o[:androidKeystore])}\""+
			" --android-storepass \"#{@o[:androidStorepass]}\""+
			" --android-alias \"#{@o[:androidAlias]}\""+
			" --android-keypass \"#{@o[:androidKeypass]}\""+
			" --show-passwords"+
			" --output-type interpreted"+
			@o[:extraParameters].to_s
		FileUtils.cd(@o[:tempdir], :verbose => true) do
			sh cmd
		end
		FileUtils.touch @NAME
	end
end
